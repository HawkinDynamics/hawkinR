---
title: "Create And Maintain A Local Database"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{Create And Maintain A Local Database}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
---

```{r setup, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>"
)

library(knitr)
```

# Why Store Data Locally

To make a long story short, it's just easier for everyone. Data stored locally, or to a file, can be called and manipulated faster than retrieving the data from the cloud. Also, there are limitations to how much data can be called at once. Some of you may have come across this in the form of a 500 error when trying to call too many tests at once. And in reality, it is hard to say what the maximum number of tests is when querying via the API, as the size of the file returned will depend on a few factors. If you do analysis or create reports that utilize your entire database regularly, it might be a good idea to save your data to a local file. Here are a few benefits:

-   Faster calling and manipulation compared to API queries
-   Relatively small file sizes (compared to most modern storage capacities)
-   Easily update and maintain to stay in sync with remote server
-   Easily share or extend your analysis to other programs and machines

# How To Create Your Local Database

Creating and maintaining a local database is as simple as a couple lines of code. Simply initialize a new session by running the `get_access()` function to gain secure access to your organizations tenant, then execute the `buildDB()` function with the necessary parameters:

-   `startDate`: The date you want to start calling tests from. For most users, this can be any date prior to the first test. But users can choose to start a database from a specific time point. This will accept a date as a character string with the format "YYYY-MM-DD" or an EPOCH timestamp.
-   `testType`: Option to create a database specific to test type or a singular data base with all test types. This will accept test type canonical ID, formal name, or abbreviation. Default to "all".
-   `includeInactive`: Option to include inactive tests in the database. `TRUE` will include inactive tests, while `FALSE` will exclude inactive tests. Default to `FALSE`.
-   `fileName`: Provide the desired file name, including a complete file path to where the file should be saved. If a path is not declared, it will be saved in the projects working directory by default. A file extension can be provided here but is not necessary.
-   `fileType`: Provide the desired file type to be saved as. RDS files can be saved with varying versions of compression methods.
-   `span`: Control how many days should be called at once when retrieving tests from the cloud. Some users may collect hundreds of tests in a day and may need to reduce the number to avoid reaching rate limitations. This is default to 14 days. While most users can expand this up to 30 or even 60 days, some user with high volume may need to reduce to 7.

```{r eval=FALSE}
# Update to hawkinR v1.2.0 -----
devtools::install_github("HawkinDynamics/hawkinR", upgrade = 'always', force = TRUE)

# Load package -----
library(hawkinR)

# Initialize session -----
get_access(refreshToken = "MY_REFRESH_TOKEN")

# Build database and save to file
buildDB(
  startDate = "2020-01-01",
  testType = "all", # options c("all", "CMJ", "SJ", "ISO", "DJ", "FR", "CMJR", "MR", "WI", "DL","TSFR","TSISO")
  includeInactive = FALSE,
  fileName = "C:/Users/My-Force-Plate-Project/my-database.rds",
  fileType = "rds", # options c("csv", "xlsx", "rds", "rds_gz", "rds_bz2", "rds_xz", "parquet", "feather") 
  span = 14
)
```

# Updating Your Local Database

Now that you have a local database created. It is very simple to keep it up to date with new tests, or even edited past tests. The `syncDB()` function does most of the work. You just need to supply the path to the current database file. Then, like before, simply specify if you want the sync to include inactive tests. The function will identify the file type from the file extension, and if the database is of all test types or a particular unique test type, so no specification is needed.

If the file is saved in the same directory as the base of the working directory, you can simply provide the file name. Else, you need to provide the specific path.

You also have the option to create a new updated file with `syncDB()` by giving a new file path and name to the `newFile` parameter. While this is not necessary, this allows for safe updates with out overwrites. As the original file is still used to duplicate previous tests, and only new or synced tests are called. With the original file preserved, the user can choose which file to maintain or remove after review.

```{r eval=FALSE}

# If file is saved in same location as project working directory
syncDB(file = "my-database.rds")

# Give explicit path to file
syncDB(file = "C:/Users/My-Force-Plate-Project/my-database.rds")

# Update database to new file
syncDB(file = "my-database.rds", newFile = "my-newest-database.rds")
```

And that's it! Your file will be saved back to it's original path (or in its new path).

Now you can manage your database locally and increase efficiency.
